3 Features of ROP Attack
3 ROP攻击的特点
The key to ROP attack detection is finding the differences between ROP malicious code and normal programs. One of the important factors in ROP is the gadget length. [20] found that instruction sequences used in ROP attacks range from two to five instructions. DROP [17] found that the number of the instructions in the gadget is no more than 5. Kayaalp et al. [25] extracted gadgets from standard C library and conducted studies on average gadget lengths. The result showed that as the gadget length grew the number of side effects grew linearly making them increasingly more difficult to use.
ROP攻击检测的关键是发现ROP恶意代码和普通程序之间的差异。 ROP中的一个重要因素是小工具长度。 [20]发现ROP攻击中使用的指令序列范围从2到5个指令。 DROP [17]发现小工具中的指令数不超过5. Kayaalp等。 [25]从标准C库中提取小工具，并对平均小工具长度进行了研究。结果表明，随着小工具长度的增加，副作用的数量呈线性增长，使得它们越来越难以使用。
There are also some other factors being considered in present detecting mechanisms. DynIMA [20] reports a ROP attack if three of small instruction sequences were executed one after another. Fan Yao et al. [38] found that it is relatively hard to find gadgets within short distances.
在目前的检测机制中还考虑了一些其他因素。如果三个小指令序列一个接一个地执行，DynIMA [20]会报告ROP攻击。范瑶等。 [38]发现在短距离内找到小工具相对比较困难。
Based on the experience of writing ROP malicious code, we find out other two features. First, contiguous gadgets, no matter ending with jump or call instructions, do not locate in the same routine. Second, shellcodes always leverage system call to transfer the flow of control to the kernel mode.
基于编写ROP恶意代码的经验，我们发现了其他两个特性。首先，无论是跳转还是调用指令，连续的小工具都不会位于同一个例程中。其次，shellcode总是利用系统调用将控制流转移到内核模式。
In computer programming, routine is a sequence of code that is intended to be called and used repeatedly during the execution of a program. In high-level languages, many commonly-needed routines are packaged as functions. In the traditional ROP attacks, each gadget ends with the return instruction. At most time, they are not in the same routine except recursive returns. We extract gadgets from glibc by ROPGadget [8], which is an open source tool to search gadgets, and construct some JOP malicious code with the algorithm proposed by [12]. We find that it is extremely hard to use contiguous gadgets that are in the same routine.
在计算机编程中，例程是一系列代码，用于在程序执行期间重复调用和使用。在高级语言中，许多通常需要的例程被打包为函数。在传统的ROP攻击中，每个小工具都以返回指令结束。在大多数情况下，除了递归返回之外，它们不在同一个例程中。我们通过ROPGadget [8]从glibc中提取小工具，这是一个搜索小工具的开源工具，并使用[12]提出的算法构造一些​​JOP恶意代码。我们发现使用相同例程的连续小工具非常困难。
ROP malicious code is the derivation of shellcode and bases on the traditional shellcode to construct gadgets. We analyze all 247 shellcodes from [5] and find that 212 of them invoke system call at least once. However, to evade the IDs detecting mechanisms, other shellcodes encrypt or self-modify payloads and do not use “int 0x80” directly to avoid containing sensitive data (e.g., cd 80). But anyway they will invoke system call at runtime to get higher privilege. [2] invokes kernel vsyscall function that uses sysenter instruction to transfer the control flow from user mode running at privilege level 3 to operating system. However, sysenter instruction provides a fast entry to the kernel and also can be considered as another kind of system call.
ROP恶意代码是shellcode的衍生，基于传统的shellcode构建小工具。我们分析[5]中的所有247个shellcode，发现其中212个至少调用一次系统调用。但是，为了规避ID检测机制，其他shellcode加密或自修改有效载荷，并且不直接使用“int 0x80”以避免包含敏感数据（例如，cd 80）。但无论如何，他们将在运行时调用系统调用以获得更高的权限。 [2]调用内核vsyscall函数，该函数使用sysenter指令将控制流从在特权级别3运行的用户模式传输到操作系统。但是，sysenter指令提供了对内核的快速输入，也可以被视为另一种系统调用。
We consider the (i) small gadget size, (ii) the execution of system call and (iii) contiguous candidate gadgets are not in the same routine as the ROP attack’s most representative characteristics. Based on these three differences between ROP malicious code and normal programs, we develop a tool named ROP-Hunt, which dynamically detects ROP attack by checking whether the execution trace deviates from the normal execution route. We will show the design of ROP-Hunt in the next section.
我们认为（i）小工具大小，（ii）系统调用的执行和（iii）连续候选小工具与ROP攻击最具代表性的特征不在同一程序中。基于ROP恶意代码和普通程序之间的这三个差异，我们开发了一个名为ROP-Hunt的工具，它通过检查执行跟踪是否偏离正常执行路径来动态检测ROP攻击。我们将在下一节中展示ROP-Hunt的设计。