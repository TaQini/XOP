4 ROP-Hunt Design and Implementation
Based on the features of ROP attack, we propose our approach to efficiently detect ROP attacks. Since we assume no access to source code, we make use of instrumentation technique that allows to add extra code to a program to observe and debug the program's behavior [29].

4.1 Assumptions and Definitions
In this paper, we define the number of instructions in a gadget as G_size. Candidate gadget refers to the gadget that G_size is greater than the threshold T0. The length of contiguous candidate gadget sequence is defined as S_length, and Max(S length) represents the maximum values of S length.
In order to simulate the real environment, we make the following assumptions:
1. We assume that the underlying system supports DEP [1] model that prohibits writing to executable memory. In this case, code injection based attacks are impossible. Modern processors and operating systems already enable DEP by default.
2. We assume that the attacker is able to perform a buffer overflow [19,31,39], a string formatting attack or a non-local jump buffer (using setjmp and longjmp [4]) to mount a ROP attack. 
3. We assume that the attacker operates in the user mode and the vulnerability exploited to initiate the attack does not lead to a privilege escalation. 
4. We assume that we have no access to source code.

4.2 System Overview
Figure 3 shows the flow chart of ROP-Hunt. According to the features of ROP that we have analyzed in Sect. 3, ROP-Hunt monitors the program dynamically, intercepts the system call instruction and three control flow sensitive instructions: call, jmp and ret. There are two categories of ROP report: Warning and Attack. Warning indicates that there is a serious risk that the process is under a ROP attack. Since it have not invoked a system call to visit the underlying system sources, we believe that it is not ready to do any meaningful attack. If the statistic values break the thresholds and a system call is being invoked, ROP-Hunt will kill the process appending with an Attack report.
- Report Warning: When ROP-Hunt recognizes these three instructions (call, indirect jump and return), it checks whether the length of instruction sequence is greater than T0. If not, it extracts the target address and the current instruction address. Especially for ret instruction, the target address will be popped from the stack. Then ROP-Hunt checks whether the two addresses locate in the same routine. If not, we record the instruction sequence as a candidate gadget. Next, we count the maximum length of contiguous candidate gadgets S length. If S length is less than or equal to T1, we will set the potential attack flag to True and raise a Warning.
- Report Attack: System call is the only way to transfer the flow of control from user space to kernel space. When a system call instruction is recognized, ROP-Hunt checks whether the potential attack flag is True. If the condition is satisfied, ROP-Hunt will report an Attack and terminate the process.

4.3 Implementation Details
To demonstrate the effectiveness and evaluate the performance of our approach, we have developed a prototype implementation for the Ã—86 32-bit version of Ubuntu 14.04 with kernel 3.19. For our prototype, ROP-Hunt, we used the binary instrumentation framework Pin [28] (version 2.14).
We incorporated ROP-Hunt directly into the Pin Framework. Pin is a tool for the instrumentation of programs and instruments all instructions that are actually executed. There are two kinds of working mode in Pin, probe mode and just-in-time (JIT) mode. In JIT mode, Pin can intercept each instruction before it is executed by the processor, even if the instruction was not intended by the programmer.
[Fig. 3. Work flow of ROP-Hunt]
To instrument a binary at runtime, we have to determine where code is inserted and what code to execute at insertion points. Pin provides instrumentation tools which are called Pintools. Pintools are written in the C/C++ programming language using Pin's rich API and allow to specify your own instrumentation code. We designed and implemented our own Pintool to detect ROP attacks in the Pin framework.
The overall architecture of the runtime system is depicted in Fig. 4. Our architecture consists of the Pin Framework and the Pintool ROP-Hunt. Pin is the engine that jits and instruments the program binary. Pin itself consists of a virtual machine (VM), a code cache, and instrumentation APIs invoked by Pintools. The VM consists of a JIT compiler, an emulator and a dispatcher. When a program is started, the JIT compiles and instruments instructions, which are then launched by the dispatcher. The compiled instructions are stored in the code cache in order to reduce performance overhead if code pieces are invoked multiple times. The emulator interprets instructions that cannot be executed directly.
Our Pintool, ROP-Hunt, consists of a record unit and a detection unit which contains instrumentation routines and analysis routines. The detection unit leverages instrumentation APIs to communicate with Pin and the record unit just stores the statistic values at runtime.
[Fig. 4. Implementation of ROP-Hunt within pin framework]

4.4 Instrumentation and Analysis Routines
As mentioned in Sect. 4.1, one of the key points is to recognize the instruction types. The instrumentation routines of our ROP-Hunt use the inspection functions INS_IsSyscall(INS ins), INS_IsSysenter(INS ins) provided by the Pin APIs to determine whether the current instruction is a system call or a system enter, and use INS_IsIndirectBranchOrCall(INS ins) to determine whether the current instruction is a branch instruction. If the current instruction is an indirect jump, call or return instruction, then we invoke an analysis function that extracts the addresses of both the current instruction and the target.
POP-Hunt assigns each routine an ID. The ID is globally unique, i.e., an ID will not appear in two images. If the same routine name exists in two different images (i.e., they are in different addresses), each will have a different ID. If an image is unloaded and then reloaded, the routines within it will most likely have different IDs than before. ROP-Hunt leverages the function PIN InitSymbols() to initialize the symbol table and read symbols from the binary. Since then, we can get the routine ID by the address.
The record unit allocates data space to each thread respectively. We use the thread local storage (TLS) from the Pin APIs to avoid that one thread accesses the record of another thread.