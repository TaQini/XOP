7 Evaluation
In this section, we evaluated the security effectiveness and the performance overhead of ROP-Hunt. All experiments were performed on a computer with the following specifications: Intel Core i3 2370M CPU, 4 GB RAM, 32-bit Ubuntu with kernel version 3.19. For the security evaluation, we verify our approach with two real-world ROP attacks and a small program that has a simple stack buffer overflow triggered by a long input parameter. For the performance evaluation, we used 18 C and C++ SPEC CPU2006 [10] benchmarks for our experiments. The benchmarks were compiled using gcc-4.8.3 compiler.
To further assess ROP-Hunt detection capabilities, we used a simple target program that had a strcpy vulnerability (demonstrated in [31]). The program were compiled by gcc-4.8.4 and linked with glibc-2.3.5. We used ROPGadget [8] to analyze the program and generate usable gadgets. We manually chained candidate gadgets together to rewrite 30 representative shellcode from the Shell-Storm Linux shellcode repository [5]. These shellcodes were composed of combinational gadgets which ending with ret, jmp or call instructions. Gadgets longer than 7 instructions were extremely difficult to incorporate due to side effects. The most simple attack required 4 gadgets (greater than T1 ). As we have analyzed in Sect. 3, all shellcodes used system calls to complete attacks. The experimental result showed that ROP-Hunt could detect all these ROP attacks without false positive.

7.2 Performance Overhead
We chose the benchmark tool SPEC CPU2006 benchmark suite [10] to measure the performance of ROP-Hunt. Specifically, we ran the testing suits with and without ROP-Hunt. The results are illustrated in Fig. 6, which shows that applications under protection of ROP-Hunt run on average 1.75x. The slowdown for benchmarks ranges from 1.05x to 2.41x. We compared ROP-Hunt with other ROP detectors based on instrumentation technique. According to the results in [17,21], applications running under ROPdefender and DROP are 2.17x and 5.3x. [18] causes an average slowdown of 3.5x.
Fig. 6. SPEC CPU2006 benchmark results
The result shows that the Pin framework itself also induces an average slowdown of 1.66x. We believe the performance of ROP-Hunt will be continuously improved with the optimization of Pin Framework.

8 Discussion 
We design and implement ROP-Hunt to detect ROP attacks at runtime, and currently ROP-Hunt is based on dynamic binary instrumentation tool Pin. Although ROP-Hunt is effective detecting ROP attacks, there are some limitations. First, ROP-Hunt only detects ROP malicious code on x86 architecture. However, malicious code can be rewritten on other architectures by ROP technique. We believe that our approach can be deployed to other architectures. Second, ROP-Hunt detects ROP attack with the assumption that all ROP malicious codes meet the thresholds discussed in Sect. 5. Although it is extremely hard, there is a theoretical possibility that some ROP attacks may break this assumption. Finally, ROP-Hunt is implemented by using the jit-based binary instrumentation framework Pin and causes an average slowdown of 1.75x. The performance overhead may be unacceptable for some time-critical applications.

9 Conclusions
ROP is a very powerful exploitation technique used to bypass current security mechanisms. In this paper, we studied and extracted the features of the ROP malicious code. Based on the identification of distinctive attributes of ROP malicious code that are inherently exhibited during execution, we proposed a novel and practical approach for protecting against ROP attack without requiring access to source code. The experimental results showed that our prototype, ROP-Hunt, successfully detects all ROP attacks with no false positive. ROP-Hunt leverages instrumentation technique and adds a runtime overhead of 1.75x which is comparable to similar instrumentation-based ROP detection tools. As part of our future work, we plan to port our prototype implementation to other architectures. 

Acknowledgments. We thank the anonymous reviewers for their constructive comments that guided the final version of this paper. We thank National University of Defense Technology for providing essential conditions to accomplish this paper. This work is supported by the NSFC under Grant 61103015, 61303191, 61402504 and 61303190.
